#version 450
const uint BBF_SIZE = 25;

layout(local_size_x = 1, local_size_y = 1) in;

layout(set = 0, binding = 0) buffer UKnot {
    float uknot[];
};

layout(set = 0, binding = 1) buffer VKnot {
    float vknot[];
};

layout(set = 0, binding = 2) buffer UDiv {
    float udiv[];
};

layout(set = 0, binding = 3) buffer VDiv {
    float vdiv[];
};

layout(set = 0, binding = 4) buffer ControlPoints {
    vec4 control_points[];
};

layout(set = 0, binding = 5) buffer UDerivedControlPoints {
    vec4 uderived_control_points[];
};

layout(set = 0, binding = 6) buffer VDerivedControlPoints {
    vec4 vderived_control_points[];
};

layout(set = 0, binding = 7) uniform SurfaceInfo {
    uint uknot_length;
    uint vknot_length;
    uint udiv_length;
    uint vdiv_length;
    uint ucp_length;
    uint vcp_length;
};

layout(set = 0, binding = 8) buffer VertexBuffer {
    float vertex_buffer[];
};

layout(set = 0, binding = 9) buffer IndexBuffer {
    uint index_buffer[];
};

float inv_or_zero(float a) {
    if (abs(a) < 1.0e-7) {
        return 0.0;
    } else {
        return 1.0 / a;
    }
}

uint udegree() {
    return uknot_length - ucp_length - 1;
}

uint vdegree() {
    return vknot_length - vcp_length - 1;
}

// bspline basis function
float[BBF_SIZE] u_bbf(float u, uint degree, uint len) {
    float[BBF_SIZE] res;
    for (uint i = 0; i < len; i++) {
        res[i] = 0.0;
    }
    
    uint idx = len;
    for (uint i = 0; i < len; i++) {
        if (u < uknot[i]) {
            idx = i - 1;
            break;
        }
    }
    if (idx == len) {
        res[len - degree - 2] = 1.0;
        return res;
    }
    res[idx] = 1.0;

    for (uint k = 1; k <= degree; k++) {
        uint base = 0;
        if (idx >= k) base = idx - k;
        float delta = uknot[base + k] - uknot[base];
        uint maximum = idx;
        if (idx + k + 1 >= len)  maximum = len - k - 2;
        float a = inv_or_zero(delta) * (u - uknot[base]);
        for (uint i = base; i <= maximum; i++) {
            float delta = uknot[i + k + 1] - uknot[i + 1];
            float b = inv_or_zero(delta) * (uknot[i + k + 1] - u);
            res[i] = a * res[i] + b * res[i + 1];
            a = 1.0 - b;
        }
    }

    return res;
}

// bspline basis function
float[BBF_SIZE] v_bbf(float v, uint degree, uint len) {
    float[BBF_SIZE] res;
    for (uint i = 0; i < len; i++) {
        res[i] = 0.0;
    }
    
    uint idx = len;
    for (uint i = 0; i < len; i++) {
        if (v < vknot[i]) {
            idx = i - 1;
            break;
        }
    }
    if (idx == len) {
        res[len - degree - 2] = 1.0;
        return res;
    }
    res[idx] = 1.0;

    for (uint k = 1; k <= degree; k++) {
        uint base = 0;
        if (idx >= k) base = idx - k;
        float delta = vknot[base + k] - vknot[base];
        uint maximum = idx;
        if (idx + k + 1 >= len)  maximum = len - k - 2;
        float a = inv_or_zero(delta) * (v - vknot[base]);
        for (uint i = base; i <= maximum; i++) {
            float delta = vknot[i + k + 1] - vknot[i + 1];
            float b = inv_or_zero(delta) * (vknot[i + k + 1] - v);
            res[i] = a * res[i] + b * res[i + 1];
            a = 1.0 - b;
        }
    }

    return res;
}

vec4 surface(float u, float v) {
    float[BBF_SIZE] ubasis = u_bbf(u, udegree(), uknot_length);
    float[BBF_SIZE] vbasis = v_bbf(v, vdegree(), vknot_length);
    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);
    for (uint i = 0; i < ucp_length; i++) {
        for (uint j = 0; j < vcp_length; j++) {
            res += ubasis[i] * vbasis[j] * control_points[i * vcp_length + j];
        }
    }
    return res;
}

vec4 uderived_surface(float u, float v) {
    float[BBF_SIZE] ubasis = u_bbf(u, udegree() - 1, uknot_length);
    float[BBF_SIZE] vbasis = v_bbf(v, vdegree(), vknot_length);
    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);
    for (uint i = 0; i < ucp_length + 1; i++) {
        for (uint j = 0; j < vcp_length; j++) {
            res += ubasis[i] * vbasis[j] * uderived_control_points[i * vcp_length + j];
        }
    }
    return res;
}

vec4 vderived_surface(float u, float v) {
    float[BBF_SIZE] ubasis = u_bbf(u, udegree(), uknot_length);
    float[BBF_SIZE] vbasis = v_bbf(v, vdegree() - 1, vknot_length);
    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);
    for (uint i = 0; i < ucp_length; i++) {
        for (uint j = 0; j < vcp_length + 1; j++) {
            res += ubasis[i] * vbasis[j] * vderived_control_points[i * (vcp_length + 1) + j];
        }
    }
    return res;
}

void create_vertex_buffer() {
    float u = udiv[gl_GlobalInvocationID.x];
    float v = vdiv[gl_GlobalInvocationID.y];
    vec4 pt = surface(u, v);
    vec4 uder = uderived_surface(u, v);
    vec4 vder = vderived_surface(u, v);
    vec3 uder_rat = vec3(
        uder[0] * pt[3] - pt[0] * uder[3],
        uder[1] * pt[3] - pt[1] * uder[3],
        uder[2] * pt[3] - pt[2] * uder[3]
    ) / (pt[3] * pt[3]);
    vec3 vder_rat = vec3(
        vder[0] * pt[3] - pt[0] * vder[3],
        vder[1] * pt[3] - pt[1] * vder[3],
        vder[2] * pt[3] - pt[2] * vder[3]
    ) / (pt[3] * pt[3]);
    vec3 n = normalize(cross(uder_rat, vder_rat));
    uint offset = (gl_GlobalInvocationID.x * vdiv_length + gl_GlobalInvocationID.y) * 8;

    vertex_buffer[offset + 0] = pt[0] / pt[3];
    vertex_buffer[offset + 1] = pt[1] / pt[3];
    vertex_buffer[offset + 2] = pt[2] / pt[3];
    vertex_buffer[offset + 3] = u;
    vertex_buffer[offset + 4] = v;
    vertex_buffer[offset + 5] = n[0];
    vertex_buffer[offset + 6] = n[1];
    vertex_buffer[offset + 7] = n[2];
}

void create_index_buffer() {
    uint i = gl_GlobalInvocationID.x;
    uint j = gl_GlobalInvocationID.y;
    uint idx = (i * (vdiv_length - 1) + j) * 6;
    index_buffer[idx + 0] = i * vdiv_length + j;
    index_buffer[idx + 1] = (i + 1) * vdiv_length + j;
    index_buffer[idx + 2] = i * vdiv_length + (j + 1);
    index_buffer[idx + 3] = (i + 1) * vdiv_length + (j + 1);
    index_buffer[idx + 4] = i * vdiv_length + (j + 1);
    index_buffer[idx + 5] = (i + 1) * vdiv_length + j;
}

void main() {
    create_vertex_buffer();
    if (gl_GlobalInvocationID.x != udiv_length - 1 && gl_GlobalInvocationID.y != vdiv_length - 1) {
        create_index_buffer();
    }
}
