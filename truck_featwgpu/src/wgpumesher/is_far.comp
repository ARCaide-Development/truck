#version 450
layout(local_size_x = 1) in;

layout(set = 0, binding = 0) buffer UKnot {
    double uknot[];
};

layout(set = 0, binding = 1) buffer VKnot {
    double vknot[];
};

layout(set = 0, binding = 2) buffer UDiv {
    double udiv[];
};

layout(set = 0, binding = 3) buffer VDiv {
    double vdiv[];
};

layout(set = 0, binding = 4) buffer ControlPoints {
    dvec4 control_points[];
};

layout(set = 0, binding = 5) uniform SurfaceInfo {
    uint uknot_length;
    uint vknot_length;
    uint udiv_length;
    uint vdiv_length;
    uint ucp_length;
    uint vcp_length;
};

layout(set = 0, binding = 6) uniform TOLERANCE {
    double tol;
}

layout(set = 0, binding = 7) buffer UIsFar {
    uint uis_far[];
};

layout(set = 0, binding = 8) buffer VIsFar {
    uint vis_far[];
};

double inv_or_zero(double a) {
    if (abs(a) < 1.0e-7) {
        return 0.0;
    } else {
        return 1.0 / a;
    }
}

uint udegree() {
    return uknot_length - ucp_length - 1;
}

uint vdegree() {
    return vknot_length - vcp_length - 1;
}

// bspline basis function
double[100] u_bbf(double u, uint degree, uint len) {
    double[100] res;
    for (uint i = 0; i < len; i++) {
        res[i] = 0.0;
    }
    
    uint idx = len;
    for (uint i = 0; i < len; i++) {
        if (u < uknot[i]) {
            idx = i - 1;
            break;
        }
    }
    if (idx == len) {
        res[len - degree - 2] = 1.0;
        return res;
    }
    res[idx] = 1.0;

    for (uint k = 1; k <= degree; k++) {
        uint base = 0;
        if (idx >= k) base = idx - k;
        double delta = uknot[base + k] - uknot[base];
        uint maximum = idx;
        if (idx + k + 1 >= len)  maximum = len - k - 2;
        double a = inv_or_zero(delta) * (u - uknot[base]);
        for (uint i = base; i <= maximum; i++) {
            double delta = uknot[i + k + 1] - uknot[i + 1];
            double b = inv_or_zero(delta) * (uknot[i + k + 1] - u);
            res[i] = a * res[i] + b * res[i + 1];
            a = 1.0 - b;
        }
    }

    return res;
}

// bspline basis function
double[100] v_bbf(double v, uint degree, uint len) {
    double[100] res;
    for (uint i = 0; i < len; i++) {
        res[i] = 0.0;
    }
    
    uint idx = len;
    for (uint i = 0; i < len; i++) {
        if (v < vknot[i]) {
            idx = i - 1;
            break;
        }
    }
    if (idx == len) {
        res[len - degree - 2] = 1.0;
        return res;
    }
    res[idx] = 1.0;

    for (uint k = 1; k <= degree; k++) {
        uint base = 0;
        if (idx >= k) base = idx - k;
        double delta = vknot[base + k] - vknot[base];
        uint maximum = idx;
        if (idx + k + 1 >= len)  maximum = len - k - 2;
        double a = inv_or_zero(delta) * (v - vknot[base]);
        for (uint i = base; i <= maximum; i++) {
            double delta = vknot[i + k + 1] - vknot[i + 1];
            double b = inv_or_zero(delta) * (vknot[i + k + 1] - v);
            res[i] = a * res[i] + b * res[i + 1];
            a = 1.0 - b;
        }
    }

    return res;
}

dvec4 surface(double u, double v) {
    double[100] ubasis = u_bbf(u, udegree(), uknot_length);
    double[100] vbasis = v_bbf(v, vdegree(), vknot_length);
    dvec4 res = dvec4(0.0, 0.0, 0.0, 0.0);
    for (uint i = 0; i < ucp_length; i++) {
        for (uint j = 0; j < vcp_length; j++) {
            res += ubasis[i] * vbasis[j] * control_points[i * vcp_length + j];
        }
    }
    return res;
}

uint uis_far() {
    double u0 = udiv[gl_GlobalInvocationID.x];
    double u1 = udiv[gl_GlobalInvocationID.x + 1];
    uis_far[gl_GlobalInvocationID.x] = 0;
    uint degree0 = 2 * udegree();
    uint degree1 = 2 * vdegree();
    for (uint j = 0; j < vknot_length - 1; j++) {
        double v0 = vdiv[j];
        double v1 = vdiv[j + 1];
        dvec4 pt00_4 = surface(u0, v0);
        dvec3 pt00 = surface00_4.xyz / surface00_4.w;
        dvec4 pt01_4 = surface(u0, v1);
        dvec3 pt01 = surface01_4.xyz / surface01_4.w;
        dvec4 pt10_4 = surface(u1, v0);
        dvec3 pt10 = surface10_4.xyz / surface10_4.w;
        dvec4 pt11_4 = surface(u1, v1);
        dvec3 pt11 = surface11_4.xyz / surface11_4.w;
        for (uint k = 0; k < degree0; k++) {
            for (uint l = 0; l < degree1; l++) {
                double p = double(k) / double(degree0);
                double q = double(l) / double(degree1);
                double u = u0 * p + u1 * (1.0 - p);
                double v = v0 * q + v1 * (1.0 - q);
                dvec4 pt0_4 = surface(u, v);
                dvec3 pt0 = pt0_4.xyz / pt0_4[3];
                dvec3 pt1 = pt00 * p * q
                    + pt01 * p * (1.0 - q)
                    + pt10 * (1.0 - p) * q
                    + pt11 * (1.0 - p) * (1.0 - q);
                if (distance(pt0, pt1) >= tol) {
                    uis_far[gl_GlobalInvocationID.x] = 1;
                    return;
                }
            }
        }
    }
}

uint vis_far() {
    double v0 = vdiv[gl_GlobalInvocationID.x];
    double v1 = vdiv[gl_GlobalInvocationID.x + 1];
    vis_far[gl_GlobalInvocationID.x] = 0;
    uint degree0 = 2 * udegree();
    uint degree1 = 2 * vdegree();
    for (uint i = 0; i < uknot_length - 1; i++) {
        double u0 = vdiv[i];
        double u1 = vdiv[i + 1];
        dvec4 pt00_4 = surface(u0, v0);
        dvec3 pt00 = surface00_4.xyz / surface00_4.w;
        dvec4 pt01_4 = surface(u0, v1);
        dvec3 pt01 = surface01_4.xyz / surface01_4.w;
        dvec4 pt10_4 = surface(u1, v0);
        dvec3 pt10 = surface10_4.xyz / surface10_4.w;
        dvec4 pt11_4 = surface(u1, v1);
        dvec3 pt11 = surface11_4.xyz / surface11_4.w;
        for (uint k = 0; k < degree0; k++) {
            for (uint l = 0; l < degree1; l++) {
                double p = double(k) / double(degree0);
                double q = double(l) / double(degree1);
                double u = u0 * p + u1 * (1.0 - p);
                double v = v0 * q + v1 * (1.0 - q);
                dvec4 pt0_4 = surface(u, v);
                dvec3 pt0 = pt0_4.xyz / pt0_4[3];
                dvec3 pt1 = pt00 * p * q
                    + pt01 * p * (1.0 - q)
                    + pt10 * (1.0 - p) * q
                    + pt11 * (1.0 - p) * (1.0 - q);
                if (distance(pt0, pt1) >= tol) {
                    vis_far[gl_GlobalInvocationID.x] = 1;
                    return;
                }
            }
        }
    }
}

void main() {
    if (gl_GlobalInvocationID.x < udiv_length - 1) {
        uis_far();
    }
    if (gl_GlobalInvocationID.x < vdiv_length - 1) {
        vis_far();
    }
}
