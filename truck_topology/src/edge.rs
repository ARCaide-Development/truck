use crate::{Result, Vertex, Edge};
use crate::errors::Error;
use crate::id::IDGenerator;

lazy_static! {
    static ref ID_GENERATOR: IDGenerator = IDGenerator::new();
}

impl Edge {
    /// generate the edge from `front` to `back`.
    /// # Panic
    /// The condition `front == back` is not allowed.
    #[inline(always)]
    pub fn new(front: Vertex, back: Vertex) -> Edge {
        if front == back {
            panic!("{:?}", Error::SameVertex);
        }

        Edge {
            vertices: (front, back),
            orientation: true,
            id: ID_GENERATOR.generate(),
        }
    }

    /// generate the edge from `front` to `back`.
    /// # Failures
    /// The condition `front == back` is not allowed.
    #[inline(always)]
    pub fn try_new(front: Vertex, back: Vertex) -> Result<Edge> {
        if front == back {
            Err(Error::SameVertex)
        } else {
            Ok(Edge {
                vertices: (front, back),
                orientation: true,
                id: ID_GENERATOR.generate(),
            })
        }
    }
    
    /// generate the edge from `front` to `back`.
    /// # Remarks
    /// This method is prepared only for performance-critical development and is not recommended.
    /// This method does NOT check the condition `front == back`.
    /// The programmer must guarantee this condition before using this method.
    #[inline(always)]
    pub fn new_unchecked(front: Vertex, back: Vertex) -> Edge {
        Edge {
            vertices: (front, back),
            orientation: true,
            id: ID_GENERATOR.generate(),
        }
    }

    /// generate the inverse oriented edge
    #[inline(always)]
    pub fn inverse(&self) -> Edge {
        Edge {
            vertices: self.vertices,
            orientation: !self.orientation,
            id: self.id,
        }
    }

    /// get the front vertex
    /// ```
    /// use truck_topology::{Vertex, Edge};
    /// let edge0 = Edge::new(Vertex::new(), Vertex::new());
    /// let edge1 = edge0.inverse();
    /// assert_eq!(edge0.front(), edge1.back());
    /// ```
    #[inline(always)]
    pub fn front(&self) -> Vertex {
        if self.orientation {
            self.vertices.0
        } else {
            self.vertices.1
        }
    }

    /// get the back vertex
    #[inline(always)]
    pub fn back(&self) -> Vertex {
        if self.orientation {
            self.vertices.1
        } else {
            self.vertices.0
        }
    }

    /// get the front vertex which is generated by constructor
    #[inline(always)]
    pub fn absolute_front(&self) -> Vertex { self.vertices.0 }
    
    /// get the back vertex which is generated by constructor
    #[inline(always)]
    pub fn absolute_back(&self) -> Vertex { self.vertices.1 }

    /// whether two edges are the same. Return `true` even if the orientaions are different.
    /// ```
    /// use truck_topology::{Vertex, Edge};
    /// let v = Vertex::news(2);
    /// let edge0 = Edge::new(v[0], v[1]);
    /// let edge1 = Edge::new(v[0], v[1]);
    /// let edge2 = edge0.clone();
    /// let edge3 = edge0.clone().inverse();
    /// assert!(!edge0.is_same(&edge1));
    /// assert!(edge0.is_same(&edge2));
    /// assert!(edge0.is_same(&edge3));
    /// ```
    #[inline(always)]
    pub fn is_same(&self, other: &Edge) -> bool { self.id == other.id }

    /// get id
    pub fn id(&self) -> usize { self.id }
}

